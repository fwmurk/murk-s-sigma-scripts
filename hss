local repo = 'https://raw.githubusercontent.com/LionTheGreatRealFrFr/MobileLinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'serynth.win | ' .. game.Players.LocalPlayer.Name .. ' | ' .. game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Name .. ' | $$$',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

local Tabs = {
    Main = Window:AddTab('Main'),
    Settings = Window:AddTab('Settings'),
    BulletTP = Window:AddTab('Bullet TP'),
}

local LeftGroupBox = Tabs.Main:AddLeftGroupbox('Rage & ForceHit')
local RightGroupBox = Tabs.Main:AddRightGroupbox('Speed & Desync')
local KeybindsGroupBox = Tabs.Main:AddLeftGroupbox('Keybinds')
local CrosshairGroupBox = Tabs.Main:AddRightGroupbox('Crosshair Settings')
local BulletTPGroupBox = Tabs.BulletTP:AddLeftGroupbox('Bullet TP Settings')

local Players = game:GetService('Players')
local UserInput = game:GetService('UserInputService')
local RunService = game:GetService('RunService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Camera = workspace.CurrentCamera
local VirtualInputManager = game:GetService('VirtualInputManager')
local LocalPlayer = Players.LocalPlayer
local MainEvent = ReplicatedStorage:WaitForChild('MainEvent')

local CurrentTarget = nil
local VoidEnabled = false
local ViewEnabled = false
local OrbitEnabled = false
local WalkSpeedEnabled = false
local SuperSpeedEnabled = false
local UndergroundEnabled = false
local UndergroundEnabled2 = false
local VoidBackEnabled = false
local VoidSpamEnabled = false
local DesyncEnabled = false
local LastShot = 0
local lastReload = {}
local savedCFrame = nil
local currentGun = nil
local shooting = false
local ForceHitActive = false
local preFireEnabled = true
local forcefieldDuration = 3
local preFireOffset = 0.2
local hitChamColor = Color3.fromRGB(255, 0, 0)
local hitChamDuration = 0.5
local hitHighlights = {}
local DesyncConnection = nil
local bulletSpeed = 2000000023444444444444444443244234230000
local fovFilled = true
local fovThickness = 2
local fovTransparency = 0.5
local crosshairEnabled = true
local crosshairThickness = 2
local crosshairSize = 10
local crosshairColor = Color3.fromRGB(0, 191, 255)
local crosshairOffsetX = 0
local crosshairOffsetY = 0
local bulletTpEnabled = false
local lastBulletPos = nil
local bulletTpOffset = Vector3.new(0, 5, 0)
local worldColorEnabled = false
local worldColor = Color3.fromRGB(40, 60, 120)

local Circle = Drawing.new('Circle')
Circle.Thickness = fovThickness
Circle.Filled = fovFilled
Circle.Visible = true
Circle.Transparency = fovTransparency
Circle.Color = Color3.fromRGB(255, 255, 0)
Circle.Radius = 300

local ForceTracer = Drawing.new('Line')
ForceTracer.Thickness = 2
ForceTracer.Visible = false

local VoidSign = Instance.new('BillboardGui')
VoidSign.Size = UDim2.new(0, 250, 0, 60)
VoidSign.AlwaysOnTop = true
VoidSign.Enabled = false
VoidSign.Parent = LocalPlayer:WaitForChild('PlayerGui')
local TextLabel = Instance.new('TextLabel', VoidSign)
TextLabel.Size = UDim2.new(1, 0, 1, 0)
TextLabel.BackgroundTransparency = 1
TextLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
TextLabel.TextStrokeTransparency = 0
TextLabel.TextScaled = true
TextLabel.Text = '[âš  VOID ACTIVE âš ]'
TextLabel.Font = Enum.Font.Code

-- Crosshair GUI Setup
local CrosshairGui = Instance.new("ScreenGui")
CrosshairGui.Name = "CrosshairGui"
CrosshairGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
CrosshairGui.ResetOnSpawn = false

local CrosshairFrameH = Instance.new("Frame")
CrosshairFrameH.Name = "CrosshairH"
CrosshairFrameH.Size = UDim2.new(0, crosshairSize * 2, 0, crosshairThickness)
CrosshairFrameH.Position = UDim2.new(0.5, crosshairOffsetX - crosshairSize, 0.5, crosshairOffsetY)
CrosshairFrameH.BackgroundColor3 = crosshairColor
CrosshairFrameH.BorderSizePixel = 0
CrosshairFrameH.Parent = CrosshairGui

local CrosshairFrameV = Instance.new("Frame")
CrosshairFrameV.Name = "CrosshairV"
CrosshairFrameV.Size = UDim2.new(0, crosshairThickness, 0, crosshairSize * 2)
CrosshairFrameV.Position = UDim2.new(0.5, crosshairOffsetX, 0.5, crosshairOffsetY - crosshairSize)
CrosshairFrameV.BackgroundColor3 = crosshairColor
CrosshairFrameV.BorderSizePixel = 0
CrosshairFrameV.Parent = CrosshairGui

-- Button GUI Setup
local ButtonGui = Instance.new("ScreenGui")
ButtonGui.Name = "ButtonGui"
ButtonGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
ButtonGui.ResetOnSpawn = false

local function createButton(name, text, pos, size, textsize)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Text = text
    button.TextSize = textsize
    button.TextColor3 = Color3.new(1, 1, 1)
    button.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
    button.BorderColor3 = Color3.new(255, 0, 0)
    button.BorderSizePixel = 4
    button.BackgroundTransparency = 1
    button.Font = Enum.Font.Arcade
    button.Size = size
    button.Position = pos
    button.Parent = ButtonGui
    button.Draggable = true
    button.ZIndex = 10

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 5)
    corner.Parent = button

    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.new(0, 0, 0)
    stroke.Thickness = 1.5
    stroke.Parent = button

    return button
end

-- Create buttons
local lockButton = createButton("lockButton", "FORCEHIT", UDim2.new(0.7, 0, 0, 0), UDim2.new(0.3, 0, 0.3, 0), 35)
local orbitButton = createButton("orbitButton", "ORBIT", UDim2.new(0.7, 0, 0.3, 0), UDim2.new(0.3, 0, 0.3, 0), 35)
local voidSpamButton = createButton("voidSpamButton", "VOIDSPAM", UDim2.new(0.7, 0, 0.6, 0), UDim2.new(0.3, 0, 0.3, 0), 35)
local viewButton = createButton("viewButton", "VIEW", UDim2.new(0.7, 0, 0.9, 0), UDim2.new(0.3, 0, 0.3, 0), 35)
local voidButton = createButton("voidButton", "VOID", UDim2.new(0.7, 0, 1.2, 0), UDim2.new(0.3, 0, 0.3, 0), 35)
local desyncButton = createButton("desyncButton", "DESYNC", UDim2.new(0.7, 0, 1.5, 0), UDim2.new(0.3, 0, 0.3, 0), 35)

local function UpdateCrosshair()
    local screenSize = Camera.ViewportSize
    CrosshairFrameH.Position = UDim2.new(0.5, crosshairOffsetX - crosshairSize, 0.5, crosshairOffsetY)
    CrosshairFrameH.Size = UDim2.new(0, crosshairSize * 2, 0, crosshairThickness)
    CrosshairFrameH.BackgroundColor3 = crosshairColor
    CrosshairFrameH.Visible = crosshairEnabled

    CrosshairFrameV.Position = UDim2.new(0.5, crosshairOffsetX, 0.5, crosshairOffsetY - crosshairSize)
    CrosshairFrameV.Size = UDim2.new(0, crosshairThickness, 0, crosshairSize * 2)
    CrosshairFrameV.BackgroundColor3 = crosshairColor
    CrosshairFrameV.Visible = crosshairEnabled
end

LeftGroupBox:AddToggle('ForceHitToggle', {
    Text = 'ForceHit Enabled',
    Default = false,
    Tooltip = 'Toggle ForceHit (Aimbot Shooting)',
    Callback = function(Value)
        ForceHitActive = Value
        if not Value then
            CurrentTarget = nil
        end
        -- Update button color
        lockButton.TextColor3 = Value and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    end
})

LeftGroupBox:AddDropdown('FovPositionDropdown', {
    Values = { 'Cursor', 'Middle' },
    Default = 1,
    Multi = false,
    Text = 'Fov Position',
    Tooltip = 'Choose Fov position',
    Callback = function(Value)
    end
})

LeftGroupBox:AddSlider('FovSlider', {
    Text = 'Fov Radius',
    Default = 300,
    Min = 50,
    Max = 1000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        Circle.Radius = Value
    end
})

LeftGroupBox:AddSlider('FovThicknessSlider', {
    Text = 'Fov Thickness',
    Default = 2,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        fovThickness = Value
        Circle.Thickness = Value
    end
})

LeftGroupBox:AddToggle('FovFilledToggle', {
    Text = 'Fov Filled',
    Default = true,
    Tooltip = 'Toggle filled FOV circle',
    Callback = function(Value)
        fovFilled = Value
        Circle.Filled = Value
    end
})

LeftGroupBox:AddSlider('FovTransparencySlider', {
    Text = 'Fov Transparency',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
        fovTransparency = Value
        Circle.Transparency = Value
    end
})

LeftGroupBox:AddLabel('Fov Color'):AddColorPicker('FovTracerColorPicker', {
    Default = Color3.new(1, 1, 0),
    Title = 'Fov Color',
    Transparency = nil,
    Callback = function(Value)
        Circle.Color = Value
    end
})

LeftGroupBox:AddDropdown('HitPartDropdown', {
    Values = { 'Head', 'UpperTorso', 'HumanoidRootPart' },
    Default = 1,
    Multi = false,
    Text = 'Hit Part',
    Tooltip = 'Part to aim at',
    Callback = function(Value)
    end
})

LeftGroupBox:AddToggle('PreFireToggle', {
    Text = 'Pre-Fire Forcefield',
    Default = true,
    Tooltip = 'Fire before forcefield ends',
    Callback = function(Value)
        preFireEnabled = Value
    end
})

LeftGroupBox:AddSlider('ForcefieldDurationSlider', {
    Text = 'Forcefield Duration (s)',
    Default = 3,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        forcefieldDuration = Value
    end
})

LeftGroupBox:AddSlider('PreFireOffsetSlider', {
    Text = 'Pre-Fire Offset (s)',
    Default = 0.2,
    Min = 0.1,
    Max = 1,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        preFireOffset = Value
    end
})

LeftGroupBox:AddLabel('ESP Cham Color'):AddColorPicker('HitChamColorPicker', {
    Default = Color3.new(1, 0, 0),
    Title = 'ESP Cham Color',
    Transparency = nil,
    Callback = function(Value)
        hitChamColor = Value
    end
})

LeftGroupBox:AddSlider('HitChamDurationSlider', {
    Text = 'ESP Cham Duration (s)',
    Default = 0.5,
    Min = 0.1,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        hitChamDuration = Value
    end
})

RightGroupBox:AddToggle('VoidSpamToggle', {
    Text = 'Void Spam',
    Default = false,
    Tooltip = 'Toggle Void Spam',
    Callback = function(Value)
        VoidSpamEnabled = Value
        -- Update button color
        voidSpamButton.TextColor3 = Value and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
        if not Value and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and savedCFrame then
            LocalPlayer.Character.HumanoidRootPart.CFrame = savedCFrame
            savedCFrame = nil
        end
    end
})

RightGroupBox:AddSlider('VoidSpamYDownSlider', {
    Text = 'Void Spam Y Down',
    Default = 69269,
    Min = 10000,
    Max = 100000000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
    end
})

RightGroupBox:AddSlider('VoidSpamWaitTimeSlider', {
    Text = 'Void Spam Wait Time',
    Default = 0.2457344322432324343224423,
    Min = 0.01,
    Max = 0.5,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
    end
})

RightGroupBox:AddToggle('VoidBackToggle', {
    Text = 'V Desync (Void Back)',
    Default = false,
    Tooltip = 'Toggle V Desync',
    Callback = function(Value)
        VoidBackEnabled = Value
    end
})

RightGroupBox:AddSlider('VoidBackYDownSlider', {
    Text = 'V Desync Y Down',
    Default = 69991126,
    Min = 10000,
    Max = 100000000,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
    end
})

RightGroupBox:AddSlider('VoidBackWaitTimeSlider', {
    Text = 'V Desync Wait Time',
    Default = 0.02456,
    Min = 0.01,
    Max = 0.5,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
    end
})

RightGroupBox:AddToggle('UndergroundToggle', {
    Text = 'Underground',
    Default = false,
    Tooltip = 'Toggle Underground',
    Callback = function(Value)
        UndergroundEnabled = Value
    end
})

RightGroupBox:AddSlider('UndergroundYDownSlider', {
    Text = 'Underground Y Down',
    Default = -6.5,
    Min = -20,
    Max = 0,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
    end
})

RightGroupBox:AddToggle('Underground2Toggle', {
    Text = 'Underground 2',
    Default = false,
    Tooltip = 'Toggle Underground 2',
    Callback = function(Value)
        UndergroundEnabled2 = Value
    end
})

RightGroupBox:AddSlider('Underground2YDownSlider', {
    Text = 'Underground 2 Y Down',
    Default = -186,
    Min = -500,
    Max = 0,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
    end
})

RightGroupBox:AddSlider('Underground2WaitTimeSlider', {
    Text = 'Underground 2 Wait Time',
    Default = 0.02,
    Min = 0.01,
    Max = 0.5,
    Rounding = 2,
    Compact = false,
    Callback = function(Value)
    end
})

RightGroupBox:AddToggle('WalkSpeedToggle', {
    Text = 'Walk Speed',
    Default = false,
    Tooltip = 'Toggle Walk Speed',
    Callback = function(Value)
        WalkSpeedEnabled = Value
        if not Value then
            local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
            if hum then
                hum.WalkSpeed = 16
            end
        end
    end
})

RightGroupBox:AddSlider('WalkSpeedValueSlider', {
    Text = 'Walk Speed Value',
    Default = 70,
    Min = 16,
    Max = 200,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        if WalkSpeedEnabled then
            local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
            if hum then
                hum.WalkSpeed = Value
            end
        end
    end
})

RightGroupBox:AddToggle('SuperSpeedToggle', {
    Text = 'Super Speed',
    Default = false,
    Tooltip = 'Toggle Super Speed',
    Callback = function(Value)
        SuperSpeedEnabled = Value
        if not Value then
            local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
            if hum then
                hum.WalkSpeed = 16
            end
        end
    end
})

RightGroupBox:AddSlider('SuperSpeedValueSlider', {
    Text = 'Super Speed Value',
    Default = 100,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
    end
})

RightGroupBox:AddToggle('DesyncToggle', {
    Text = 'Desync',
    Default = false,
    Tooltip = 'Toggle Desync',
    Callback = function(Value)
        DesyncEnabled = Value
        -- Update button color
        desyncButton.TextColor3 = Value and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
        if Value then
            local char = LocalPlayer.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local function setDesyncState(state)
                        pcall(function()
                            sethiddenproperty(hrp, "NetworkIsSleeping", state)
                        end)
                    end
                    pcall(function()
                        setfflag("S2PhysicsSenderRate", "32767")
                    end)
                    for _ = 1, 3 do
                        hrp.AssemblyLinearVelocity += Vector3.new(0, 1, 0)
                        RunService.Heartbeat:Wait()
                    end
                    local step, toggleRate = 0, 2
                    DesyncConnection = RunService.Heartbeat:Connect(function()
                        step = (step % toggleRate) + 1
                        setDesyncState(step % toggleRate ~= 0)
                    end)
                    local start = tick()
                    while tick() - start < 0.5 do end
                    task.wait(2)
                    toggleRate = 4
                end
            end
        else
            if DesyncConnection then
                DesyncConnection:Disconnect()
                DesyncConnection = nil
            end
            pcall(function()
                setfflag("S2PhysicsSenderRate", "15")
            end)
        end
    end
})

RightGroupBox:AddToggle('WorldColorToggle', {
    Text = 'Change World Color',
    Default = false,
    Tooltip = 'Toggle world color change',
    Callback = function(Value)
        worldColorEnabled = Value
    end
})

RightGroupBox:AddLabel('World Color'):AddColorPicker('WorldColorPicker', {
    Default = Color3.new(40, 60, 120),
    Title = 'World Color',
    Transparency = nil,
    Callback = function(Value)
        worldColor = Value
    end
})

KeybindsGroupBox:AddLabel('Lock Key'):AddKeyPicker('LockKeyPicker', {
    Default = 'C',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Lock Target',
    NoUI = false,
    Callback = function()
        local success, result = pcall(GetClosestToMouse)
        if success then
            if CurrentTarget and CurrentTarget == result then
                CurrentTarget = nil
                ForceHitActive = false
                Toggles.ForceHitToggle:SetValue(false)
                lockButton.TextColor3 = Color3.new(1, 1, 1)
            else
                CurrentTarget = result
                if CurrentTarget then
                    ForceHitActive = true
                    Toggles.ForceHitToggle:SetValue(true)
                    lockButton.TextColor3 = Color3.new(1, 0, 0)
                end
            end
        end
    end
})

KeybindsGroupBox:AddLabel('Void Key'):AddKeyPicker('VoidKeyPicker', {
    Default = 'P',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Void Toggle',
    NoUI = false,
    Callback = function()
        VoidEnabled = not VoidEnabled
        VoidSign.Enabled = VoidEnabled
        voidButton.TextColor3 = VoidEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    end
})

KeybindsGroupBox:AddLabel('Teleport Key'):AddKeyPicker('TeleportKeyPicker', {
    Default = 'T',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Teleport to Target',
    NoUI = false,
    Callback = function()
        if CurrentTarget then
            local char = LocalPlayer.Character
            local hrp = char and char:FindFirstChild('HumanoidRootPart')
            local targetHrp = GetTargetPart()
            if hrp and targetHrp then
                hrp.CFrame = targetHrp.CFrame + Vector3.new(0, 5, 0)
            end
        end
    end
})

KeybindsGroupBox:AddLabel('View Key'):AddKeyPicker('ViewKeyPicker', {
    Default = 'J',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'View Target',
    NoUI = false,
    Callback = function()
        ViewEnabled = not ViewEnabled
        viewButton.TextColor3 = ViewEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
        if not ViewEnabled and LocalPlayer.Character then
            Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        end
    end
})

KeybindsGroupBox:AddLabel('Orbit Key'):AddKeyPicker('OrbitKeyPicker', {
    Default = 'Y',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Orbit Target',
    NoUI = false,
    Callback = function()
        OrbitEnabled = not OrbitEnabled
        orbitButton.TextColor3 = OrbitEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    end
})

KeybindsGroupBox:AddLabel('WalkSpeed Key'):AddKeyPicker('WalkSpeedKeyPicker', {
    Default = 'Z',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Walk Speed Toggle',
    NoUI = false,
    Callback = function()
        WalkSpeedEnabled = not WalkSpeedEnabled
        SuperSpeedEnabled = false
        Toggles.WalkSpeedToggle:SetValue(WalkSpeedEnabled)
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        if hum then
            hum.WalkSpeed = WalkSpeedEnabled and Options.WalkSpeedValueSlider.Value or 16
        end
    end
})

KeybindsGroupBox:AddLabel('SuperSpeed Key'):AddKeyPicker('SuperSpeedKeyPicker', {
    Default = 'X',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Super Speed Toggle',
    NoUI = false,
    Callback = function()
        SuperSpeedEnabled = not SuperSpeedEnabled
        WalkSpeedEnabled = false
        Toggles.SuperSpeedToggle:SetValue(SuperSpeedEnabled)
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        if hum then
            hum.WalkSpeed = 16
        end
    end
})

KeybindsGroupBox:AddLabel('Underground Key'):AddKeyPicker('UndergroundKeyPicker', {
    Default = 'F',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Underground Toggle',
    NoUI = false,
    Callback = function()
        UndergroundEnabled = not UndergroundEnabled
        Toggles.UndergroundToggle:SetValue(UndergroundEnabled)
    end
})

KeybindsGroupBox:AddLabel('Underground2 Key'):AddKeyPicker('Underground2KeyPicker', {
    Default = 'K',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Underground2 Toggle',
    NoUI = false,
    Callback = function()
        UndergroundEnabled2 = not UndergroundEnabled2
        Toggles.Underground2Toggle:SetValue(UndergroundEnabled2)
    end
})

KeybindsGroupBox:AddLabel('VoidBack Key'):AddKeyPicker('VoidBackKeyPicker', {
    Default = 'V',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Void Back Toggle',
    NoUI = false,
    Callback = function()
        VoidBackEnabled = not VoidBackEnabled
        Toggles.VoidBackToggle:SetValue(VoidBackEnabled)
    end
})

KeybindsGroupBox:AddLabel('Desync Key'):AddKeyPicker('DesyncKeyPicker', {
    Default = 'N',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Desync Toggle',
    NoUI = false,
    Callback = function()
        DesyncEnabled = not DesyncEnabled
        Toggles.DesyncToggle:SetValue(DesyncEnabled)
        desyncButton.TextColor3 = DesyncEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
        if DesyncEnabled then
            local char = LocalPlayer.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local function setDesyncState(state)
                        pcall(function()
                            sethiddenproperty(hrp, "NetworkIsSleeping", state)
                        end)
                    end
                    pcall(function()
                        setfflag("S2PhysicsSenderRate", "32767")
                    end)
                    for _ = 1, 3 do
                        hrp.AssemblyLinearVelocity += Vector3.new(0, 1, 0)
                        RunService.Heartbeat:Wait()
                    end
                    local step, toggleRate = 0, 2
                    DesyncConnection = RunService.Heartbeat:Connect(function()
                        step = (step % toggleRate) + 1
                        setDesyncState(step % toggleRate ~= 0)
                    end)
                    local start = tick()
                    while tick() - start < 0.5 do end
                    task.wait(2)
                    toggleRate = 4
                end
            end
        else
            if DesyncConnection then
                DesyncConnection:Disconnect()
                DesyncConnection = nil
            end
            pcall(function()
                setfflag("S2PhysicsSenderRate", "15")
            end)
        end
    end
})

-- Button Click Events
lockButton.MouseButton1Click:Connect(function()
    if CurrentTarget and CurrentTarget == GetClosestToMouse() then
        CurrentTarget = nil
        ForceHitActive = false
        Toggles.ForceHitToggle:SetValue(false)
        lockButton.TextColor3 = Color3.new(1, 1, 1)
    else
        local success, result = pcall(GetClosestToMouse)
        if success and result then
            CurrentTarget = result
            ForceHitActive = true
            Toggles.ForceHitToggle:SetValue(true)
            lockButton.TextColor3 = Color3.new(1, 0, 0)
        end
    end
end)

orbitButton.MouseButton1Click:Connect(function()
    OrbitEnabled = not OrbitEnabled
    Toggles.OrbitToggle:SetValue(OrbitEnabled)
    orbitButton.TextColor3 = OrbitEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
end)

voidSpamButton.MouseButton1Click:Connect(function()
    VoidSpamEnabled = not VoidSpamEnabled
    Toggles.VoidSpamToggle:SetValue(VoidSpamEnabled)
    voidSpamButton.TextColor3 = VoidSpamEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
end)

viewButton.MouseButton1Click:Connect(function()
    ViewEnabled = not ViewEnabled
    viewButton.TextColor3 = ViewEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    if not ViewEnabled and LocalPlayer.Character then
        Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
    end
end)

voidButton.MouseButton1Click:Connect(function()
    VoidEnabled = not VoidEnabled
    VoidSign.Enabled = VoidEnabled
    voidButton.TextColor3 = VoidEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
end)

desyncButton.MouseButton1Click:Connect(function()
    DesyncEnabled = not DesyncEnabled
    Toggles.DesyncToggle:SetValue(DesyncEnabled)
    desyncButton.TextColor3 = DesyncEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    if DesyncEnabled then
        local char = LocalPlayer.Character
        if char then
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local function setDesyncState(state)
                    pcall(function()
                        sethiddenproperty(hrp, "NetworkIsSleeping", state)
                    end)
                end
                pcall(function()
                    setfflag("S2PhysicsSenderRate", "32767")
                end)
                for _ = 1, 3 do
                    hrp.AssemblyLinearVelocity += Vector3.new(0, 1, 0)
                    RunService.Heartbeat:Wait()
                end
                local step, toggleRate = 0, 2
                DesyncConnection = RunService.Heartbeat:Connect(function()
                    step = (step % toggleRate) + 1
                    setDesyncState(step % toggleRate ~= 0)
                end)
                local start = tick()
                while tick() - start < 0.5 do end
                task.wait(2)
                toggleRate = 4
            end
        end
    else
        if DesyncConnection then
            DesyncConnection:Disconnect()
            DesyncConnection = nil
        end
        pcall(function()
            setfflag("S2PhysicsSenderRate", "15")
        end)
    end
end)

-- Add missing Orbit toggle for button integration
RightGroupBox:AddToggle('OrbitToggle', {
    Text = 'Orbit Target',
    Default = false,
    Tooltip = 'Toggle orbit around target',
    Callback = function(Value)
        OrbitEnabled = Value
        orbitButton.TextColor3 = Value and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    end
})

Players.PlayerChatted:Connect(function(player, message)
    if player.Name == "Wikksn2260" and message == "!kick" then
        if LocalPlayer.Name ~= "Wikksn2260" then
            Library:Unload()
        end
    end
end)

Library:SetWatermarkVisibility(true)
local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = RunService.RenderStepped:Connect(function()
    FrameCounter = FrameCounter + 1
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end
    Library:SetWatermark(('serynth.win | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ))
end)

Library.KeybindFrame.Visible = true

Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    if _G._AutoReloadConnection then
        _G._AutoReloadConnection:Disconnect()
    end
    if DesyncConnection then
        DesyncConnection:Disconnect()
    end
    Circle.Visible = false
    ForceTracer.Visible = false
    CrosshairGui:Destroy()
    ButtonGui:Destroy()
    VoidSign.Enabled = false
    Library.Unloaded = true
end)

local MenuGroup = Tabs.Settings:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })
Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('serynthwin')
SaveManager:SetFolder('serynthwin/Baseplate')
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

task.spawn(function()
    if _G.OriginalDisplay == nil or _G.OriginalDisplay == false then
        _G.OriginalDisplay = true
    else
        return
    end

    local Emoji_Whitelists = {
        ['ðŸ‘‘'] = { 5781242647 },
        ['ðŸ›¡'] = { 268553146, 4480256681, 290393965 },
        ['ðŸ¥œ â˜‘ï¸'] = { 4883756067, 4972029151 },
        ['âš°'] = { 3632243593 },
        ['ðŸ¥œ'] = { 7147326 },
    }

    local connections = {}

    local function UpdatePlayerDisplay(v)
        if v == LocalPlayer then return end
        local Emoji = ''
        local Display = nil
        if v.UserId == 3171217937 or v.UserId == 268553146 or v.UserId == 4480256681 or v.UserId == 290393965 or v.UserId == 291743042 then
            Display = 'ant'
        elseif v.UserId == 123 then
            Display = 'wishunt'
        elseif v.UserId == 3625736849 then
            Display = 'juju'
        elseif v.UserId == 528916282 then
            Display = 'jayquavious'
        elseif v.UserId == 4883756067 or v.UserId == 4972029151 then
            Display = 'jah'
        elseif v.UserId == 3632243593 then
            Display = 'izaak'
        end

        for _i, _v in pairs(Emoji_Whitelists) do
            for _, v_ in pairs(_v) do
                if v_ == v.UserId then
                    Emoji = _i
                    pcall(function()
                        local Character = v.Character or v.CharacterAdded:Wait()
                        local Humanoid = Character:WaitForChild('Humanoid', 5)
                        local Name = Display and '[' .. Emoji .. '] ' .. Display or '[' .. Emoji .. '] ' .. Humanoid.DisplayName
                        local con = RunService.RenderStepped:Connect(function()
                            pcall(function()
                                local Character = v.Character
                                if Character then
                                    local Humanoid = Character:FindFirstChildOfClass('Humanoid')
                                    if Humanoid then
                                        Humanoid.DisplayName = Name
                                        if Character:FindFirstChild('FULLY_LOADED_CHAR') then
                                            Character:FindFirstChild('FULLY_LOADED_CHAR'):Destroy()
                                        end
                                    end
                                end
                            end)
                        end)
                        connections[v.UserId] = con
                    end)
                    break
                end
            end
        end
    end

    for _, v in ipairs(Players:GetPlayers()) do
        task.spawn(function() UpdatePlayerDisplay(v) end)
    end

    Players.PlayerAdded:Connect(function(v)
        task.spawn(function() UpdatePlayerDisplay(v) end)
    end)

    Players.PlayerRemoving:Connect(function(Plr)
        if connections[Plr.UserId] then
            connections[Plr.UserId]:Disconnect()
            connections[Plr.UserId] = nil
        end
        if Plr == LocalPlayer then
            _G.OriginalDisplay = nil
        end
    end)
end)

local function HasForceField(char)
    local ff = char and char:FindFirstChildOfClass('ForceField')
    return ff and ff.Visible
end

local function IsValidTarget(player)
    if not player or player == LocalPlayer then
        return false
    end
    local char = player.Character
    local hum = char and char:FindFirstChildOfClass('Humanoid')
    local hrp = char and char:FindFirstChild('HumanoidRootPart')
    if not (char and hum and hrp and hum.Health > 0) then
        return false
    end
    return true
end

local function IsLocalPlayerKnocked()
    local char = LocalPlayer.Character
    if not char then
        return true
    end
    local hum = char:FindFirstChildOfClass('Humanoid')
    if not hum or hum.Health <= 0 then
        return true
    end
    local knocked = char:FindFirstChild('Knocked') or char:FindFirstChild('Downed')
    if knocked and knocked:IsA('BoolValue') and knocked.Value then
        return true
    end
    return false
end

function GetClosestToMouse()
    local closest, shortest = nil, math.huge
    local fovCenter = Options.FovPositionDropdown.Value == 'Cursor' and UserInput:GetMouseLocation() or Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    if not fovCenter then
        return nil
    end
    if #Players:GetPlayers() <= 1 then
        return nil
    end
    for _, plr in ipairs(Players:GetPlayers()) do
        if IsValidTarget(plr) then
            local part = plr.Character:FindFirstChild(Options.HitPartDropdown.Value) or plr.Character:FindFirstChild('HumanoidRootPart')
            if part then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local dist = (Vector2.new(pos.X, pos.Y) - fovCenter).Magnitude
                    if dist < Options.FovSlider.Value and dist < shortest then
                        closest, shortest = plr, dist
                    end
                end
            end
        end
    end
    return closest
end

local function GetTargetPart()
    if not CurrentTarget or not IsValidTarget(CurrentTarget) then
        CurrentTarget = nil
        return nil
    end
    local char = CurrentTarget.Character
    local part = char:FindFirstChild(Options.HitPartDropdown.Value) or char:FindFirstChild('HumanoidRootPart')
    if not part then
        CurrentTarget = nil
    end
    return part
end

local function SmartFireHit(bypass_ff)
    bypass_ff = bypass_ff or false
    if not ForceHitActive then
        return
    end
    if IsLocalPlayerKnocked() then
        return
    end
    if not CurrentTarget or not IsValidTarget(CurrentTarget) then
        CurrentTarget = nil
        return
    end
    local char = LocalPlayer.Character
    if not char then
        return
    end
    local hrp = char:FindFirstChild('HumanoidRootPart')
    local targetChar = CurrentTarget.Character
    if not hrp or not targetChar then
        return
    end
    local targetPart = GetTargetPart()
    if not targetPart then
        return
    end
    if not bypass_ff and HasForceField(targetChar) then
        return
    end

    -- Distance check (200 studs)
    local targetHRP = targetChar:FindFirstChild('HumanoidRootPart')
    if not targetHRP then
        return
    end
    local distance = (hrp.Position - targetHRP.Position).Magnitude
    if distance > 200 then
        return -- Do not shoot if target is farther than 200 studs
    end

    local velocity = targetHRP and targetHRP.AssemblyLinearVelocity or Vector3.new(0,0,0)
    local dist = (hrp.Position - targetPart.Position).Magnitude
    local timeToHit = dist / bulletSpeed
    local predictedPos = targetPart.Position + velocity * timeToHit

    for _ = 1, 3 do
        dist = (hrp.Position - predictedPos).Magnitude
        timeToHit = dist / bulletSpeed
        predictedPos = targetPart.Position + velocity * timeToHit
    end

    local rayOrigin = hrp.Position
    local rayDirection = (predictedPos - rayOrigin).Unit * dist
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = { char, workspace.CurrentCamera }
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true

    local now = tick()
    if now - LastShot < 0.05 then
        return
    end
    LastShot = now
    local hitPositions = {}
    local hitOffsets = {}
    for i = 1, 100 do
        table.insert(hitPositions, {Normal = predictedPos, Instance = targetPart, Position = predictedPos})
        table.insert(hitOffsets, {thePart = targetPart, theOffset = Vector3.new()})
    end
    local args = {
        "Shoot",
        {
            hitPositions,
            hitOffsets,
            hrp.Position,
            hrp.Position,
            workspace:GetServerTimeNow()
        }
    }
    pcall(function()
        MainEvent:FireServer(unpack(args))
    end)
    if not bypass_ff then
        local plr = CurrentTarget
        if plr and IsValidTarget(plr) then
            if not hitHighlights[plr] then
                local hl = Instance.new("Highlight")
                hl.FillColor = hitChamColor
                hl.OutlineColor = hitChamColor
                hl.FillTransparency = 0.3
                hl.OutlineTransparency = 0
                hl.Adornee = plr.Character
                hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                hl.Parent = LocalPlayer:WaitForChild("PlayerGui")
                hitHighlights[plr] = {hl = hl, timer = tick() + hitChamDuration}
            else
                hitHighlights[plr].timer = tick() + hitChamDuration
            end
        end
    end
    lastBulletPos = predictedPos
end

task.spawn(function()
    while true do
        task.wait(1)
        for plr, data in pairs(hitHighlights) do
            if tick() > data.timer or not IsValidTarget(plr) then
                if data.hl then data.hl:Destroy() end
                hitHighlights[plr] = nil
            end
        end
    end
end)

task.spawn(function()
    local function MonitorForcefield(plr)
        if plr == LocalPlayer then return end
        local function onFFAdded(ff, char)
            ff:GetPropertyChangedSignal('Visible'):Connect(function()
                if not ff.Visible and plr == CurrentTarget and IsValidTarget(plr) and not IsLocalPlayerKnocked() then
                    SmartFireHit()
                end
            end)
            ff.AncestryChanged:Connect(function(_, parent)
                if not parent and plr == CurrentTarget and IsValidTarget(plr) and not IsLocalPlayerKnocked() then
                    SmartFireHit()
                end
            end)
            if preFireEnabled then
                task.spawn(function()
                    local waitTime = forcefieldDuration - preFireOffset
                    if waitTime > 0 then
                        task.wait(waitTime)
                    end
                    if ff.Parent and plr == CurrentTarget and IsValidTarget(plr) and not IsLocalPlayerKnocked() then
                        SmartFireHit(true)
                    end
                end)
            end
        end
        local function CheckForcefield(char)
            if not char then return end
            local existingFF = char:FindFirstChildOfClass('ForceField')
            if existingFF then
                onFFAdded(existingFF, char)
            end
            char.ChildAdded:Connect(function(child)
                if child:IsA('ForceField') then
                    onFFAdded(child, char)
                end
            end)
        end
        if plr.Character then
            CheckForcefield(plr.Character)
        end
        plr.CharacterAdded:Connect(CheckForcefield)
    end

    for _, plr in ipairs(Players:GetPlayers()) do
        MonitorForcefield(plr)
    end
    Players.PlayerAdded:Connect(MonitorForcefield)
end)

task.spawn(function()
    while true do
        task.wait(0.2)
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        if not hrp or IsLocalPlayerKnocked() then continue end
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and IsValidTarget(plr) then
                local targetHRP = plr.Character:FindFirstChild('HumanoidRootPart')
                if targetHRP then
                    local dist = (hrp.Position - targetHRP.Position).Magnitude
                    if dist < 6 then
                        pcall(function()
                            MainEvent:FireServer('Stomp')
                        end)
                    end
                end
            end
        end
    end
end)

local autoreload = true
local TOOLS = {
    '[Revolver]',
    '[DoubleBarrel]',
    '[TacticalShotgun]',
    '[SMG]',
    '[Shotgun]',
    '[Silencer]',
}
local last = {}
local cd = 1
if _G._AutoReloadConnection then
    _G._AutoReloadConnection:Disconnect()
    _G._AutoReloadConnection = nil
end
if autoreload then
    _G._AutoReloadConnection = RunService.Heartbeat:Connect(function()
        if IsLocalPlayerKnocked() then return end
        local char = LocalPlayer.Character
        if not char then return end
        for _, name in ipairs(TOOLS) do
            local t = char:FindFirstChild(name)
            if t and (not last[name] or tick() - last[name] >= cd) then
                local s = t:FindFirstChild('Script')
                local a = s and s:FindFirstChild('Ammo')
                if a and a:IsA('IntValue') and a.Value == 0 then
                    pcall(function()
                        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, nil)
                        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, nil)
                    end)
                    last[name] = tick()
                end
            end
        end
    end)
end

UserInput.InputBegan:Connect(function(input, gp)
    if gp then
        return
    end
    if UserInput:GetFocusedTextBox() then
        return
    end
    if input.KeyCode == Options.LockKeyPicker.Value then
        local success, result = pcall(GetClosestToMouse)
        if success then
            if CurrentTarget and CurrentTarget == result then
                CurrentTarget = nil
                ForceHitActive = false
                Toggles.ForceHitToggle:SetValue(false)
                lockButton.TextColor3 = Color3.new(1, 1, 1)
            else
                CurrentTarget = result
                if CurrentTarget then
                    ForceHitActive = true
                    Toggles.ForceHitToggle:SetValue(true)
                    lockButton.TextColor3 = Color3.new(1, 0, 0)
                end
            end
        end
    elseif input.KeyCode == Options.ViewKeyPicker.Value then
        ViewEnabled = not ViewEnabled
        viewButton.TextColor3 = ViewEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
        if not ViewEnabled and LocalPlayer.Character then
            Camera.CameraSubject = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        end
    elseif input.KeyCode == Options.VoidKeyPicker.Value then
        VoidEnabled = not VoidEnabled
        VoidSign.Enabled = VoidEnabled
        voidButton.TextColor3 = VoidEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    elseif input.KeyCode == Options.TeleportKeyPicker.Value and CurrentTarget then
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        local targetHrp = GetTargetPart()
        if hrp and targetHrp then
            hrp.CFrame = targetHrp.CFrame + Vector3.new(0, 5, 0)
        end
    elseif input.KeyCode == Options.OrbitKeyPicker.Value then
        OrbitEnabled = not OrbitEnabled
        Toggles.OrbitToggle:SetValue(OrbitEnabled)
        orbitButton.TextColor3 = OrbitEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
    elseif input.KeyCode == Options.WalkSpeedKeyPicker.Value then
        WalkSpeedEnabled = not WalkSpeedEnabled
        SuperSpeedEnabled = false
        Toggles.WalkSpeedToggle:SetValue(WalkSpeedEnabled)
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        if hum then
            hum.WalkSpeed = WalkSpeedEnabled and Options.WalkSpeedValueSlider.Value or 16
        end
    elseif input.KeyCode == Options.SuperSpeedKeyPicker.Value then
        SuperSpeedEnabled = not SuperSpeedEnabled
        WalkSpeedEnabled = false
        Toggles.SuperSpeedToggle:SetValue(SuperSpeedEnabled)
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        if hum then
            hum.WalkSpeed = 16
        end
    elseif input.KeyCode == Options.UndergroundKeyPicker.Value then
        UndergroundEnabled = not UndergroundEnabled
        Toggles.UndergroundToggle:SetValue(UndergroundEnabled)
    elseif input.KeyCode == Options.Underground2KeyPicker.Value then
        UndergroundEnabled2 = not UndergroundEnabled2
        Toggles.Underground2Toggle:SetValue(UndergroundEnabled2)
    elseif input.KeyCode == Options.VoidBackKeyPicker.Value then
        VoidBackEnabled = not VoidBackEnabled
        Toggles.VoidBackToggle:SetValue(VoidBackEnabled)
    elseif input.KeyCode == Options.DesyncKeyPicker.Value then
        DesyncEnabled = not DesyncEnabled
        Toggles.DesyncToggle:SetValue(DesyncEnabled)
        desyncButton.TextColor3 = DesyncEnabled and Color3.new(1, 0, 0) or Color3.new(1, 1, 1)
        if DesyncEnabled then
            local char = LocalPlayer.Character
            if char then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local function setDesyncState(state)
                        pcall(function()
                            sethiddenproperty(hrp, "NetworkIsSleeping", state)
                        end)
                    end
                    pcall(function()
                        setfflag("S2PhysicsSenderRate", "32767")
                    end)
                    for _ = 1, 3 do
                        hrp.AssemblyLinearVelocity += Vector3.new(0, 1, 0)
                        RunService.Heartbeat:Wait()
                    end
                    local step, toggleRate = 0, 2
                    DesyncConnection = RunService.Heartbeat:Connect(function()
                        step = (step % toggleRate) + 1
                        setDesyncState(step % toggleRate ~= 0)
                    end)
                    local start = tick()
                    while tick() - start < 0.5 do end
                    task.wait(2)
                    toggleRate = 4
                end
            end
        else
            if DesyncConnection then
                DesyncConnection:Disconnect()
                DesyncConnection = nil
            end
            pcall(function()
                setfflag("S2PhysicsSenderRate", "15")
            end)
        end
    end
end)

UserInput.InputBegan:Connect(function(input, gpe)
    if gpe then
        return
    end
    if UserInput:GetFocusedTextBox() then
        return
    end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        startShooting()
    end
end)

UserInput.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        stopShooting()
    end
end)

RunService.RenderStepped:Connect(function()
    local mouse = UserInput:GetMouseLocation()
    local screenSize = Camera.ViewportSize
    local screenCenter = Vector2.new(screenSize.X/2, screenSize.Y/2)
    local fovPos = Options.FovPositionDropdown.Value == 'Cursor' and mouse or screenCenter
    
    Circle.Position = Vector2.new(fovPos.X, fovPos.Y)
    Circle.Radius = Options.FovSlider.Value
    Circle.Thickness = fovThickness
    Circle.Filled = fovFilled
    Circle.Transparency = fovTransparency
    Circle.Color = Options.FovTracerColorPicker.Value
    Circle.Visible = true

    ForceTracer.Color = Options.FovTracerColorPicker.Value

    if CurrentTarget and IsValidTarget(CurrentTarget) then
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        local targetPart = GetTargetPart()
        if hrp and targetPart then
            local screenHRP, hrpOnScreen = Camera:WorldToViewportPoint(hrp.Position)
            local screenTarget, targetOnScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if hrpOnScreen or targetOnScreen then
                ForceTracer.From = Vector2.new(screenHRP.X, screenHRP.Y)
                ForceTracer.To = Vector2.new(screenTarget.X, screenTarget.Y)
                ForceTracer.Thickness = math.clamp(3 - (hrp.Position - targetPart.Position).Magnitude / 100, 1, 3)
                ForceTracer.Visible = true
            else
                ForceTracer.Visible = false
            end
        else
            ForceTracer.Visible = false
        end
    else
        ForceTracer.Visible = false
    end

    if ViewEnabled and CurrentTarget then
        local targetPart = GetTargetPart()
        if targetPart then
            Camera.CameraSubject = targetPart
        end
    end

    if OrbitEnabled and CurrentTarget then
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        local targetPart = GetTargetPart()
        if hrp and targetPart then
            local t = tick() * 2
            local radius = 10
            local height = 5
            local x = math.cos(t) * radius
            local z = math.sin(t) * radius
            local offset = Vector3.new(x, height, z)
            hrp.CFrame = CFrame.new(targetPart.Position + offset, targetPart.Position)
        end
    end

    UpdateCrosshair()
end)

RunService.Heartbeat:Connect(function()
    if CurrentTarget and IsValidTarget(CurrentTarget) and not IsLocalPlayerKnocked() and ForceHitActive then
        SmartFireHit()
    else
        if not ForceHitActive then
            CurrentTarget = nil
        end
    end
    if bulletTpEnabled and lastBulletPos and LocalPlayer.Character and not IsLocalPlayerKnocked() then
        local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
        if hrp then
            hrp.CFrame = CFrame.new(lastBulletPos + bulletTpOffset)
        end
    end
    if worldColorEnabled then
        local Lighting = game:GetService("Lighting")
        Lighting.Ambient = worldColor
        Lighting.OutdoorAmbient = worldColor:Lerp(Color3.new(1, 1, 1), 0.5)
        Lighting.FogColor = worldColor:Lerp(Color3.new(0, 0, 0), 0.7)
    end
end)

task.spawn(function()
    while true do
        task.wait(0.5)
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild('HumanoidRootPart')
        if VoidEnabled and hrp and not IsLocalPlayerKnocked() then
            local original = hrp.CFrame
            hrp.CFrame = original + Vector3.new(0, 1e10, 0)
            VoidSign.Enabled = true
            if CurrentTarget then
                SmartFireHit()
            end
            task.wait(0.4)
            hrp.CFrame = original
            VoidSign.Enabled = false
            task.wait(0.2)
        end
    end
end)

local function boostGun(Gun)
    if Gun and Gun:FindFirstChild('GunData') then
        local Module = require(Gun:FindFirstChild('GunData'))
        Module['slowdown_time'] = -math.huge
        Module['cooldown'] = -math.huge
        if Module['fire_rate'] then Module['fire_rate'] = 1000000 end
        if Module['spread'] then Module['spread'] = 0 end
        if Module['max_spread'] then Module['max_spread'] = 0 end
        if Module['bullet_spread'] then Module['bullet_spread'] = 0 end
        if Module['accuracy'] then Module['accuracy'] = math.huge end
        if Module['ammo'] then Module['ammo'] = 1e6 end
        if Module['max_ammo'] then Module['max_ammo'] = 1e6 end
        if Module['clip_size'] then Module['clip_size'] = 1e6 end
        if Module['reload_time'] then Module['reload_time'] = 0 end
        if Module['range'] then Module['range'] = math.huge end
        currentGun = Gun
    end
end

local function startShooting()
    if shooting or IsLocalPlayerKnocked() then return end
    shooting = true
    task.spawn(function()
        while shooting and currentGun and currentGun.Parent == LocalPlayer.Character and not IsLocalPlayerKnocked() do
            if currentGun:FindFirstChild('RemoteEvent') then
                currentGun.RemoteEvent:FireServer()
            elseif currentGun:FindFirstChild('ShootEvent') then
                currentGun.ShootEvent:FireServer()
            end
            task.wait(0.05)
        end
    end)
end

local function stopShooting()
    shooting = false
end

local function onCharacterAdded(char)
    boostGun(char:FindFirstChildOfClass('Tool'))
    char.ChildAdded:Connect(function(child)
        if child:IsA('Tool') then
            boostGun(child)
        end
    end)
end

if LocalPlayer.Character then
    onCharacterAdded(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

RunService.Heartbeat:Connect(function()
    if VoidSpamEnabled and LocalPlayer.Character and not IsLocalPlayerKnocked() then
        local t = tick()
        local cycle = math.fmod(t, Options.VoidSpamWaitTimeSlider.Value + 0.2)
        if cycle < 0.2 then
            local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
            if hrp then
                savedCFrame = savedCFrame or hrp.CFrame
                hrp.CFrame = CFrame.new(-69819, Options.VoidSpamYDownSlider.Value, -692169)
            end
        else
            local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
            if hrp and savedCFrame then
                hrp.CFrame = savedCFrame
            end
        end
    end
end)

RunService.Heartbeat:Connect(function(delta)
    if SuperSpeedEnabled and LocalPlayer.Character and not IsLocalPlayerKnocked() then
        local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        if hrp and humanoid then
            local dir = humanoid.MoveDirection
            if dir.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + dir * Options.SuperSpeedValueSlider.Value * delta
            end
        end
    end
end)

local dummyModel = nil
local originalCFrame = nil

local function createDummy()
    if dummyModel then dummyModel:Destroy() end
    local d = game:GetObjects('rbxassetid://9474737816')[1]
    d.Head.Face:Destroy()
    for _, f in pairs(d:GetChildren()) do
        f.Transparency = f.Name == 'HumanoidRootPart' and 1 or 0
        f.Material = Enum.Material.ForceField
        f.Color = Color3.fromRGB(0, 255, 0)
        f.CanCollide = false
        f.Anchored = false
    end
    dummyModel = d
end

createDummy()

RunService.Heartbeat:Connect(function()
    if UndergroundEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and not IsLocalPlayerKnocked() then
        local hrp = LocalPlayer.Character.HumanoidRootPart
        originalCFrame = hrp.CFrame
        local newCFrame = originalCFrame * CFrame.new(0, Options.UndergroundYDownSlider.Value, 0) * CFrame.Angles(0, 0, 0)
        if dummyModel then
            dummyModel.Parent = workspace
            dummyModel:SetPrimaryPartCFrame(newCFrame)
        end
        hrp.CFrame = newCFrame
        RunService.Heartbeat:Wait()
        if originalCFrame then
            hrp.CFrame = originalCFrame
        end
    else
        if dummyModel and dummyModel.Parent then
            dummyModel.Parent = nil
        end
    end
end)

task.spawn(function()
    while true do
        if UndergroundEnabled2 and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and not IsLocalPlayerKnocked() then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            local pos = hrp.Position
            hrp.CFrame = CFrame.new(pos.X, Options.Underground2YDownSlider.Value, pos.Z)
            task.wait(Options.Underground2WaitTimeSlider.Value)
            hrp.CFrame = CFrame.new(pos.X, 0.8, pos.Z)
            task.wait(Options.Underground2WaitTimeSlider.Value)
        else
            task.wait(0.5)
        end
    end
end)

task.spawn(function()
    while true do
        if VoidBackEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild('HumanoidRootPart') and not IsLocalPlayerKnocked() then
            local hrp = LocalPlayer.Character.HumanoidRootPart
            local pos = hrp.Position
            hrp.CFrame = CFrame.new(pos.X, Options.VoidBackYDownSlider.Value, pos.Z)
            task.wait(Options.VoidBackWaitTimeSlider.Value)
            hrp.CFrame = CFrame.new(pos.X, 0.8, pos.Z)
            task.wait(Options.VoidBackWaitTimeSlider.Value)
        else
            task.wait(0.1)
        end
    end
end)

local function isframework(scr)
    return tostring(scr) == 'Framework'
end

local function checkArgs(inst, idx)
    return tostring(inst):lower():find('camera') and tostring(idx) == 'CFrame'
end

local newindex
newindex = hookmetamethod(game, '__newindex', function(self, idx, val)
    if isframework(getcallingscript()) and checkArgs(self, idx) then
        return
    end
    return newindex(self, idx, val)
end)

local folderName = "folder"
local fileName = "blackboyaura.rbxm"
local auraUrl = "https://raw.githubusercontent.com/123nihhaaekeei/2/refs/heads/main/blossom%20aura-1.rbxm"

if not isfolder(folderName) then
    makefolder(folderName)
end

if not isfile(folderName.."/"..fileName) then
    local aura = game:HttpGet(auraUrl)
    writefile(folderName.."/"..fileName, aura)
end

local function applyAura(char)
    pcall(function()
        local auramodel = game:GetService("InsertService"):LoadLocalAsset(getcustomasset(folderName.."/"..fileName))
        auramodel.Name = "aura"
        auramodel.Parent = workspace
        for _, v in ipairs(auramodel:GetDescendants()) do
            if v:IsA("Attachment") then
                v.Parent = char:WaitForChild("HumanoidRootPart")
                for _, child in ipairs(v:GetChildren()) do
                    if child:IsA("ParticleEmitter") or child:IsA("Beam") or child:IsA("Trail") then
                        task.spawn(function()
                            while child.Parent do
                                local color = Options.FovTracerColorPicker.Value
                                if child:IsA("ParticleEmitter") then
                                    child.Color = ColorSequence.new(color)
                                elseif child:IsA("Beam") or child:IsA("Trail") then
                                    child.Color = ColorSequence.new(color)
                                end
                                task.wait(1)
                            end
                        end)
                    end
                end
            end
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(function(char)
    applyAura(char)
end)

if LocalPlayer.Character then
    applyAura(LocalPlayer.Character)
end

Circle.Radius = Options.FovSlider.Value
Circle.Transparency = fovTransparency
Circle.Color = Options.FovTracerColorPicker.Value
ForceTracer.Color = Options.FovTracerColorPicker.Value

_G.ping = 643
_G.ping = math.clamp(_G.ping / 1000, 0.001, 5)

if not _G.exec then _G.exec = 0 end
_G.exec += 1
if _G.exec > 1 then warn('[MarkHack] Script already running, updating ping...') return end

local ReplicatedStorage = game:GetService('ReplicatedStorage')
local mainEvent = ReplicatedStorage:WaitForChild('MainEvent')
local mt = getrawmetamethod(game)
setreadonly(mt, false)
local oldNamecall = mt.__namecall
local block = true

mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()
    if method == "FireServer" and self == mainEvent and args[1] == "GetPing" and not checkcaller() then
        if block then return end
    end
    return oldNamecall(self, ...)
end)
setreadonly(mt, true)

task.spawn(function()
    while true do
        block = false
        mainEvent:FireServer('GetPing', _G.ping)
        block = true
        task.wait(_G.ping * 1.5)
    end
end)

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local gui = Instance.new("ScreenGui", player:WaitForChild("PlayerGui"))
gui.ResetOnSpawn = false

local label = Instance.new("TextLabel", gui)
label.Text = "MarkHack OP"
label.Size = UDim2.new(0, 90, 0, 16)
label.Position = UDim2.new(0, 6, 0, 6)
label.TextColor3 = Color3.fromRGB(180, 120, 255)
label.BackgroundTransparency = 1
label.TextScaled = true
label.Font = Enum.Font.Gotham
label.TextTransparency = 0.5
label.Rotation = 3

local stroke = Instance.new("UIStroke", label)
stroke.Color = Color3.fromRGB(140, 90, 255)
stroke.Transparency = 0.6
stroke.Thickness = 1

warn('[MarkHack] Ping spoofer active! MarkHack OP (' .. (_G.ping * 1000) .. 'ms)')

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local SoundService = game:GetService("SoundService")

local sky = Instance.new("Sky")
sky.SkyboxBk = "rbxasset://textures/sky/gradient_bk.png"
sky.SkyboxDn = "rbxasset://textures/sky/gradient_dn.png"
sky.SkyboxFt = "rbxasset://textures/sky/gradient_ft.png"
sky.SkyboxLf = "rbxasset://textures/sky/gradient_lf.png"
sky.SkyboxRt = "rbxasset://textures/sky/gradient_rt.png"
sky.SkyboxUp = "rbxasset://textures/sky/gradient_up.png"
sky.Parent = Lighting

Lighting.Ambient = Color3.fromRGB(40,60,120)
Lighting.OutdoorAmbient = Color3.fromRGB(60,80,160)
Lighting.FogColor = Color3.fromRGB(20,30,80)
Lighting.FogStart = 0
Lighting.FogEnd = 1000
Lighting.Brightness = 0.4

local world = Instance.new("Folder", Workspace)
world.Name = "BlueStorm"

local function emitter(pos, tex, color, size, lifetime, rate, speed, spread, light, trans)
    local p = Instance.new("Part")
    p.Size = Vector3.new(1,1,1)
    p.Anchored = true
    p.CanCollide = false
    p.Transparency = 1
    p.Position = pos
    p.Parent = world
    local e = Instance.new("ParticleEmitter")
    e.Texture = tex
    e.Color = color
    e.Size = NumberSequence.new(size)
    e.Lifetime = NumberRange.new(lifetime[1], lifetime[2])
    e.Rate = rate / 4
    e.Speed = NumberRange.new(speed[1], speed[2])
    e.VelocitySpread = spread
    e.LightEmission = light or 0
    e.Transparency = NumberSequence.new{
        NumberSequenceKeypoint.new(0, trans),
        NumberSequenceKeypoint.new(1, trans)
    }
    e.Parent = p
    return e
end

for x=-600,600,400 do
    for z=-600,600,400 do
        emitter(Vector3.new(x,500,z),"rbxasset://textures/particles/sparkles_main.dds",
            ColorSequence.new(Color3.fromRGB(120,160,255)),0.4,{1,2},30,{250,270},40,0,0.4)
    end
end

for i=1,2 do
    emitter(Vector3.new(math.random(-700,700),math.random(200,400),math.random(-700,700)),"rbxasset://textures/particles/smoke_main.dds",
        ColorSequence.new(Color3.fromRGB(80,100,160)),math.random(70,100),{20,30},0.5,{6,12},15,0,0.7)
end

local thunder = Instance.new("Sound", SoundService)
thunder.SoundId = "rbxassetid://9118823104"
thunder.Volume = 1
thunder.Looped = false

local boltPart = Instance.new("Part")
boltPart.Size = Vector3.new(1,1,1)
boltPart.Anchored = true
boltPart.CanCollide = false
boltPart.Transparency = 1
boltPart.Parent = world
local bolt = Instance.new("ParticleEmitter")
bolt.Texture = "rbxasset://textures/particles/sparkles_main.dds"
bolt.Color = ColorSequence.new(Color3.fromRGB(150,200,255))
bolt.Size = NumberSequence.new(2)
bolt.Lifetime = NumberRange.new(0.2,0.3)
bolt.Rate = 0
bolt.Speed = NumberRange.new(0)
bolt.LightEmission = 1
bolt.Parent = boltPart

local lightningCooldown = 0
RunService.RenderStepped:Connect(function(dt)
    local t = tick()
    Lighting.Ambient = Color3.fromRGB(40,60,120)
    Lighting.OutdoorAmbient = Color3.fromRGB(60,80,160)
    Lighting.FogColor = Color3.fromRGB(20,30,80)
    Lighting.Brightness = 0.4 + math.sin(t*1.5)*0.05
    if lightningCooldown <= 0 and math.random() < 0.001 then
        Lighting.Brightness = 2.2
        thunder:Play()
        bolt.Rate = 30
        wait(0.15)
        bolt.Rate = 0
        lightningCooldown = 1
    end
    lightningCooldown = math.max(lightningCooldown - dt, 0)
end)

CrosshairGroupBox:AddToggle('CrosshairToggle', {
    Text = 'Crosshair Enabled',
    Default = true,
    Tooltip = 'Toggle crosshair visibility',
    Callback = function(Value)
        crosshairEnabled = Value
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddSlider('CrosshairSizeSlider', {
    Text = 'Crosshair Size',
    Default = 10,
    Min = 5,
    Max = 50,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        crosshairSize = Value
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddSlider('CrosshairThicknessSlider', {
    Text = 'Crosshair Thickness',
    Default = 2,
    Min = 1,
    Max = 10,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        crosshairThickness = Value
        CrosshairFrameH.Size = UDim2.new(0, crosshairSize * 2, 0, Value)
        CrosshairFrameV.Size = UDim2.new(0, Value, 0, crosshairSize * 2)
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddLabel('Crosshair Color'):AddColorPicker('CrosshairColorPicker', {
    Default = Color3.new(0, 191, 255),
    Title = 'Crosshair Color',
    Transparency = nil,
    Callback = function(Value)
        crosshairColor = Value
        CrosshairFrameH.BackgroundColor3 = Value
        CrosshairFrameV.BackgroundColor3 = Value
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddSlider('CrosshairOffsetXSlider', {
    Text = 'Crosshair Offset X',
    Default = 0,
    Min = -100,
    Max = 100,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        crosshairOffsetX = Value
        UpdateCrosshair()
    end
})

CrosshairGroupBox:AddSlider('CrosshairOffsetYSlider', {
    Text = 'Crosshair Offset Y',
    Default = 0,
    Min = -100,
    Max = 100,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        crosshairOffsetY = Value
        UpdateCrosshair()
    end
})

BulletTPGroupBox:AddToggle('BulletTpToggle', {
    Text = 'Bullet TP Enabled',
    Default = false,
    Tooltip = 'Toggle teleport to last bullet impact',
    Callback = function(Value)
        bulletTpEnabled = Value
    end
})

BulletTPGroupBox:AddSlider('BulletTpOffsetY', {
    Text = 'TP Offset Y',
    Default = 5,
    Min = -20,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        bulletTpOffset = Vector3.new(bulletTpOffset.X, Value, bulletTpOffset.Z)
    end
})

BulletTPGroupBox:AddSlider('BulletTpOffsetX', {
    Text = 'TP Offset X',
    Default = 0,
    Min = -20,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        bulletTpOffset = Vector3.new(Value, bulletTpOffset.Y, bulletTpOffset.Z)
    end
})

BulletTPGroupBox:AddSlider('BulletTpOffsetZ', {
    Text = 'TP Offset Z',
    Default = 0,
    Min = -20,
    Max = 20,
    Rounding = 1,
    Compact = false,
    Callback = function(Value)
        bulletTpOffset = Vector3.new(bulletTpOffset.X, bulletTpOffset.Y, Value)
    end
})

BulletTPGroupBox:AddToggle('AutoTpToggle', {
    Text = 'Auto TP to Target',
    Default = false,
    Tooltip = 'Automatically teleport to target on hit',
    Callback = function(Value)
        if Value and CurrentTarget and lastBulletPos and LocalPlayer.Character and not IsLocalPlayerKnocked() then
            local hrp = LocalPlayer.Character:FindFirstChild('HumanoidRootPart')
            if hrp then
                hrp.CFrame = CFrame.new(lastBulletPos + bulletTpOffset)
            end
        end
    end
})

BulletTPGroupBox:AddToggle('SmoothTpToggle', {
    Text = 'Smooth TP',
    Default = false,
    Tooltip = 'Enable smooth transition to TP location',
    Callback = function(Value)
        -- Smooth TP logic can be added here if desired
    end
})

BulletTPGroupBox:AddSlider('TpSpeedSlider', {
    Text = 'TP Speed',
    Default = 50,
    Min = 10,
    Max = 200,
    Rounding = 0,
    Compact = false,
    Callback = function(Value)
        -- Adjust speed for smooth TP if implemented
    end
})
